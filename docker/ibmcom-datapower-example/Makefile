# Instructions:
#
# This project:
# A) Like a builder: make
# This will build, run, test, and tag the resulting image.  If this completes,
# then the resulting image works.
#
# B) As a developer:
#  a) make rundev
#  b) Do development!
#  c) make test, if fail, goto b
#  d) make stop fixate clean build run test
#  f) Perform other manual tests. If tests fail, make rm rundev and goto b
#  g) If happy, check in any and all resulting files
#
# A note on naming conventions:
# * The registry defaults to USER.  Override at will. Add the registry prefix.
# * The repository defaults to ibmcom-datapower-example.
# * The default name for a running container is "ibmcom-datapower-example".  Override at will,
#   remember that the name of a container must be unique on this docker engine.
# * The repository of the committed image is the same as the name of the built image
# * The tagged image is the same repository, except the tag is "latest". instead
#   of the value of TAG, which defaults to 0.1.
#
# A note on working with multiple containers:
# * The default container name is "ibmcom-datapower-example"
# * The "CONTAINER_NAME" variable can be specified on make or as an environment
#   variable.
# * One option is to have a window for each of several DataPower containers
# * And set CONTAINER_NAME=foo, where foo is unique in each window.
#
# How it works:
#
# We start from the publicly available ibmcom/datapower image. This image is
# DataPower "fresh from the factory".
#
# When we docker build the this image, we add DataPower configuration
# to DataPower in /drouter/local and /drouter/config. We also use our own CMD so
# we can run our own code prior to DataPower starting.  The code looks at
# the Docker environment and produces DataPower .cfg files in /datapower/config
# that is then loaded by a DataPower include-config.
#
# We place all of our content inside the ./src directory. This aids
# the docker build process since ./src can be copied into the new image
# via the Dockerfile. For running as a developer (without needing to build
# first), files under ./src are mapped as volumes on the 'docker run' line.
# This allows "write mem" and WebGUI "Save" to cause DataPower to write
# configuration to src/drouter/config/auto-startup.cfg and src/drouter/config/
# <domain>/<domain>.cfg. Additionally, direct editing on xsl and gatewayscript
# files is possible using one's favorite editor.
#
# When we run the resulting image, we either run it in development mode (rundev)
# or in unit test mode (run). The run target runs the built image without mounting
# volumes, so only the files built into the docker image are used. The rundev
# target runs the docker image using the datapower directory as a volume for
# /datapower.
#
# Examples of DataPower configuration that is inherited from the Docker environment
# include the DEBUG environment variable which controls some DataPower log targets and
# the creation of a load balancer group that allows distribution among all linked
# back-end servers on port 8080.
#
# This image can then be run and tested.  Once the image's validity is verified,
# it can be tagged as ibmcom-datapower-example:latest for use in the ibmcom-datapower-example project.
#
# The point of this step is to enable DataPower development workflows and
# and release engineering process. This is what allows DataPower docker images
# to be run everywhere, to adapt themselves to the running environment, and to
# integrate with deployment methodology.
#
# The resulting DataPower docker image is one that would be "docker push"ed to
# a private registry and deployed.
#
# The targets:
#
# rundev: Use this target for DataPower development.  DataPower runs, and the
# datapower/ directory is a volume.  Clicking 'save' in DataPower causes files
# to be saved in datapower/config and datapower/local where they can be used
# with version control.
#
# build: Performs the docker build.  After rundev and testing is working
# satisfactorily, use the build target to put datapower/ into a Docker image.
#
# shell: Run a busybox shell inside the container
#
# gui: Load the DataPower WebGUI in firefox
#
# run: Run the built docker image
#
# test: Test the DataPower services deployed in the running container. The
# DataPower container must be running with either rundev or run first.
#
# stop: Stop the running container
#
# rm: Delete the container
#
# clean: Remove files generated by the Makefile and the non-persisted results
# of rundev
#
# fixate: Like a photocopier, fixate takes the docker/DataPower created files
# from dev mode and fixes the permissions so the ownership is consistent with
# the rest of the project.  Use this step after rundev and before build or
# version control operations.
#
# logs: Show the docker logs for the container
#
# tag: Add the :latest tag to the result docker image
#
# NUM_BACKENDS specifies how many back-end servers should be used. It
# defaults to 3. It must be specified on the run, rundev, test, and rm
# make targets.
#
# DEBUG can be used to enable a debug log target inside DataPower. It may
# be specified on the rundev or run targets.

BASEREPOSITORY ?= ibmcom/datapower
RESULTREPOSITORY ?= $(USER)/ibmcom-datapower-example
REPOSITORY = $(RESULTREPOSITORY)
TAG ?= 0.1
CONTAINER_NAME ?= ibmcom-datapower-example
NUM_BACKENDS ?= 3

MAXWAIT = 10
DEBUG ?= 

RUNFLAGS = -it -P -e DEBUG="$(DEBUG)"

BACKEND_CONTAINER_NAMES = $(foreach backend, $(shell seq $(NUM_BACKENDS)), $(CONTAINER_NAME)-backend-$(backend))

.PHONY: all build shell crypto run rundev rm cli gui clean cryptoclean logs tag stop fixate test

all: clean build run test tag

# Make sure a listener is on a port before trying to connect with it
# Inside the container, check netstat once a second until the TCP
# port is in LISTEN.
define wait-for-listener
	@docker exec -it $(CONTAINER_NAME) /bin/sh -c \
	  'MSG="Waiting for port $(LISTENPORT) listener"; \
	  NL=""; \
	  RC=1 ; \
	  for i in `seq 1 $(MAXWAIT)`; do \
	    netstat -ln | grep -q "^tcp.*:$(LISTENPORT).*LISTEN" \
	      && { RC=0; break; }; \
	    echo -n $$MSG; \
	    MSG=.; \
	    NL="\n"; \
	    sleep 1; \
	  done; \
	  echo -ne "$$NL"; \
	  exit $$RC'
endef

# The DOCKER_HOST variable may be unset or may contain tcp://1.2.3.4:1234
# We just want to know the address of the Docker Engine we're talking to
# so it's either the IP address portion of DOCKER_HOST or it's 127.0.0.1.
ifeq '$(DOCKER_HOST)' ''
  DP_DOCKER_HOST=127.0.0.1
  DP_VBOX_INOTIFY=
else
  # remove the leading tcp://, then replace the : with a " " so we have
  # 2 words.  Lastly take just the first word, which is just the IP address
  # portion of the DOCKER_HOST.
  DP_DOCKER_HOST=$(firstword $(subst :, ,$(patsubst tcp://%,%,$(DOCKER_HOST))))
  DP_VBOX_INOTIFY=-e DP_VBOX_INOTIFY=true
endif

# The args we pass in to rundev have to be equivalent to the directives we put in the Dockerfile.
# Rundev uses a stock IBM DataPower Gateway docker image as it is provided by IBM.
# The only additions to that image are those controlled by this project.
rundev: RUNFLAGS+=-v $(PWD)/src/drouter/config:/drouter/config -v $(PWD)/src/drouter/local:/drouter/local -v $(PWD)/src/start:/start -v $(PWD)/src/start.sh:/start.sh -p 443 $(DP_VBOX_INOTIFY) -e DATAPOWER_ACCEPT_LICENSE=true -e DATAPOWER_WORKDER_THREADS=2 -e DATAPOWER_INTERACTIVE=true -p 9090
rundev: LISTENPORT=2200
rundev: REPOSITORY=$(BASEREPOSITORY)
rundev: TAG=latest
rundev: src/drouter/config src/drouter/local run
rundev: CONTAINER_CMD=/start.sh

# The Dockerfile has to be generated so we can put the correct
# BASEREPOSITORY into it
Dockerfile: Makefile
	echo '# Dockerfile generated by Makefile $(shell date)' > $@
	echo 'FROM $(BASEREPOSITORY)' >> $@
	echo 'ENV  DATAPOWER_ACCEPT_LICENSE=true \' >> $@
	echo '     DATAPOWER_WORKER_THREADS=2 \' >> $@
	echo '     DATAPOWER_INTERACTIVE=true' >> $@
	echo 'COPY src/ /' >> $@
	echo 'EXPOSE 443' >> $@
	echo 'CMD ["/start.sh"]' >> $@


build: Dockerfile crypto
	docker build -t $(RESULTREPOSITORY):$(TAG) .

shell:
	docker exec -it $(CONTAINER_NAME) /bin/sh

# Start the CLI via telnet. But first wait up to $(MAXWAIT) sec for telnet to come up.
cli: LISTENPORT=2200
cli:
	docker attach $(CONTAINER_NAME)

gui: LISTENPORT=9090
gui:
	$(wait-for-listener)
	firefox https://$(DP_DOCKER_HOST):$(shell docker inspect --format='{{(index (index .NetworkSettings.Ports "$(LISTENPORT)/tcp") 0).HostPort}}' $(CONTAINER_NAME)) > /dev/null 2>&1 &

run: crypto
	$(foreach name, $(BACKEND_CONTAINER_NAMES), docker run -d --name $(name) --hostname $(name) hstenzel/nodejs-hostname; ) true
	docker run -itd --name $(CONTAINER_NAME) $(RUNFLAGS) $(EXTRA_RUNFLAGS) $(foreach name, $(BACKEND_CONTAINER_NAMES), --link $(name)) $(REPOSITORY):$(TAG) $(CONTAINER_CMD)

test: LISTENPORT=443
test:
	$(wait-for-listener)
	curl --insecure $(foreach name, $(BACKEND_CONTAINER_NAMES), https://$(DP_DOCKER_HOST):$(shell docker inspect --format='{{(index (index .NetworkSettings.Ports "$(LISTENPORT)/tcp") 0).HostPort}}' $(CONTAINER_NAME))) | sort

stop:
	docker stop $(CONTAINER_NAME) || true

rm: stop
	docker rm $(CONTAINER_NAME) || true
	docker rm -f $(BACKEND_CONTAINER_NAMES) || true

clean:
	rm -f Dockerfile src/drouter/config/foo/loadbalancer-group.cfg src/drouter/config/debug.cfg src/drouter/config/foo/debug.cfg src/drouter/config/vbox-inotify-workaround.cfg

cryptoclean:
	rm -rf src/drouter/local/server.crt src/drouter/local/server.csr src/drouter/local/server.key src/drouter/local/foo/server.crt src/drouter/local/foo/server.key

cleaner: clean cryptoclean

# Fix permissions and ownership.
# If new docker-created root files are present; save them.
fixate:
	find src/ -user root -print0 | xargs -0 --no-run-if-empty sudo chown --reference=.

logs:
	docker logs $(CONTAINER_NAME) 2>&1

tag:
	docker tag $(REPOSITORY):$(TAG) $(REPOSITORY):latest

datapower/%:
	mkdir -p $@

.PHONY: crypto
DPPASS_CRYPTO?=superdupersecretpassword
crypto: src/drouter/local/server.crt src/drouter/local/server.csr src/drouter/local/server.key src/drouter/local/foo/server.crt src/drouter/local/foo/server.key
src/drouter/local/server.crt src/drouter/local/server.csr src/drouter/local/server.key src/drouter/local/foo/server.crt src/drouter/local/foo/server.key:
	mkdir -p src/drouter/local/foo
	cd src/drouter/local && rm -f server.crt server.csr server.key
	cd src/drouter/local && openssl genrsa -passout pass:$(DPPASS_CRYPTO) -des3 -out server.key 4096
	cd src/drouter/local && printf "$(DN_CountryCode)\n$(DN_State_Province)\n$(DN_City)\n$(DN_Organization)\n$(DN_OrgUnit)\n$(DN_CommonName)\n$(DN_EmailAddress)\n\n\n" | \
	openssl req -passin pass:$(DPPASS_CRYPTO) -new -key server.key -out server.csr
	cd src/drouter/local && openssl x509 -passin pass:$(DPPASS_CRYPTO) -req -days 365 -in server.csr -signkey server.key -out server.crt
	cp src/drouter/local/server.key src/drouter/local/foo/server.key
	cp src/drouter/local/server.crt src/drouter/local/foo/server.crt
